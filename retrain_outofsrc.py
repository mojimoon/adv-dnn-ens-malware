from learner import model_scope_dict
from tools import utils
import numpy as np
import sys
import logging
import os
import csv
from config import config

# begin config

tests = [
    # {
    #     'selection_metric': ['entropy', 'deepgini', 'dat'],
    #     'budget': [0.01, 0.03, 0.05, 0.1],
    #     'id_ratio': [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]
    # },
    # {
    #     'selection_metric': ['entropy', 'deepgini'],
    #     'budget': [0.01, 0.03, 0.05, 0.1],
    #     'id_ratio': [1.0]
    # },
    {
        'selection_metric': ['random', 'gd'],
        'budget': [0.01, 0.03, 0.05, 0.1],
        'id_ratio': [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
    },
    # {
    #     'selection_metric': ['none'],
    #     'budget': [1.0],
    #     'id_ratio': [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
    # }
]

model_name = 'deepdrebin'
retrain_type = 'type1'
test_set = 'hybrid'

# end config

TYPE1 = 'type1'
TYPE2 = 'type2'
HYBRID = 'hybrid'
ORIGINAL = 'original'
DEEPDREBIN = 'deepdrebin'
BASIC_DNN = 'basic_dnn'

class datastore:
    def __init__(self, X_path, y_path, file_type):
        self.X_path = X_path
        self.y_path = y_path
        self.file_type = file_type
        self.__load()
    
    def __load(self):
        if self.file_type == 'pkl':
            self.trainX, self.valX, self.testX = utils.read_joblib(self.X_path)
            self.trainy, self.valy, self.testy = utils.read_joblib(self.y_path)
            self.X, self.y = self.testX, self.testy
        else:
            self.X = utils.readdata_np(self.X_path)
            self.y = utils.readdata_np(self.y_path)

set_id = datastore( # 64007 + 21336 + 21336
    '/home/jzhang2297/anomaly/malware/adversarial-deep-ensemble-droidmawlare/androzoo/derbin/X.pkl',
    '/home/jzhang2297/anomaly/malware/adversarial-deep-ensemble-droidmawlare/androzoo/derbin/y.pkl',
    'pkl'
)

set_ood = {
    'drebin': datastore( # 28683 + 9562 + 9562
        '/home/jzhang2297/anomaly/malware/adversarial-deep-ensemble-droidmawlare/drebin/drebin/X.pkl',
        '/home/jzhang2297/anomaly/malware/adversarial-deep-ensemble-droidmawlare/drebin/drebin/y.pkl',
        'pkl'
    ),
    'ad2018': datastore( # 8367
        '/home/jzhang2297/anomaly/malware/adversarial-deep-ensemble-droidmawlare/androzoo/2018/feature/X.data',
        '/home/jzhang2297/anomaly/malware/adversarial-deep-ensemble-droidmawlare/androzoo/2018/feature/y.data',
        'data'
    ),
    'ad2019': datastore( # 8076
        '/home/jzhang2297/anomaly/malware/adversarial-deep-ensemble-droidmawlare/androzoo/2019/feature/X.data',
        '/home/jzhang2297/anomaly/malware/adversarial-deep-ensemble-droidmawlare/androzoo/2019/feature/y.data',
        'data'
    )
}

# print(set_ood['ad2018'].X.shape)
# print(set_ood['ad2019'].X.shape)

# sys.exit(0)

targeted_model_names_dict = model_scope_dict.copy()
targeted_model_name = 'basic_dnn'
targeted_model = targeted_model_names_dict[targeted_model_name](mode='test')

project_root = config.get('DEFAULT', 'project_root')
log_path = os.path.join(project_root, 'results', 'retrain', 'retrain_outofsrc_{}_{}_{}.csv'.format(model_name, retrain_type, test_set))

size = 4000

id_idx = np.random.choice(np.arange(len(set_id.X)), size=size, replace=False)
can_idX, can_idy = set_id.X[id_idx], set_id.y[id_idx]
test_idX, test_idy = np.delete(set_id.X, id_idx, axis=0)[:size], np.delete(set_id.y, id_idx)[:size]

trainX, trainy = set_id.trainX, set_id.trainy

ood_idx = []
can_oodX, can_oody = [], []
test_oodX, test_oody = [], []

for i, ood in enumerate(set_ood):
    ood_idx.append(np.random.choice(np.arange(len(set_ood[ood].X)), size=size, replace=False))
    can_oodX.append(set_ood[ood].X[ood_idx[i]])
    can_oody.append(set_ood[ood].y[ood_idx[i]])
    test_oodX.append(np.delete(set_ood[ood].X, ood_idx[i], axis=0)[:size])
    test_oody.append(np.delete(set_ood[ood].y, ood_idx[i])[:size])
    # print(can_oodX[i].shape, can_oody[i].shape, test_oodX[i].shape, test_oody[i].shape)

def write_to_csv(outputfile, data):
    file_exists = os.path.isfile(outputfile)
    with open(outputfile, 'a') as csvfile:
        fieldnames = ['selection_metric', 'ood', 'epochs', 'id_ratio', 'budget', 'original_acc', 'retrain_acc', 'acc_improvement']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        if not file_exists:
            writer.writeheader()
        writer.writerow(data)

def retrain_outofsrc(test_params):
    selection_metric = test_params['selection_metric']
    bg = test_params['budget']
    retrain_epochs = retrain_type == TYPE1 and [30] or [10]
    id_dist = test_params['id_ratio']
    for i, ood in enumerate(set_ood):
        for metric in selection_metric:
            for budget in bg:
                for epochs in retrain_epochs:
                    accuracies, ori_accs = [], []
                    for id_ratio in id_dist:
                        id_size = int(can_idX.shape[0] * id_ratio)
                        id_feat_can, id_y_can = can_idX[:id_size], can_idy[:id_size]
                        id_feat_test, id_y_test = test_idX[:id_size], test_idy[:id_size]

                        ood_size = size - id_size
                        ood_feat_can, ood_y_can = can_oodX[i][:ood_size], can_oody[i][:ood_size]
                        ood_feat_test, ood_y_test = test_oodX[i][:ood_size], test_oody[i][:ood_size]

                        hybrid_candidateX = np.concatenate((id_feat_can, ood_feat_can), axis=0)  # (4000, 10000)
                        hybrid_candidatey = np.concatenate((id_y_can, ood_y_can), axis=0)

                        hybrid_testX = np.concatenate((id_feat_test, ood_feat_test), axis=0)
                        hybrid_testy = np.concatenate((id_y_test, ood_y_test), axis=0)

                        _testX, _testy = hybrid_testX, hybrid_testy

                        if test_set == ORIGINAL:
                            _testX, _testy = set_id.testX, set_id.testy
                        
                        ori_acc = targeted_model.test_rpst(testX=_testX, testy=_testy, is_single_class=True)

                        retrainX, retrainy = None, None

                        if budget == 1.0:
                            if retrain_type == TYPE1:
                                retrainX, retrainy = hybrid_candidateX, hybrid_candidatey
                            else:
                                retrainX = np.concatenate((hybrid_candidateX, trainX), axis=0)
                                retrainy = np.concatenate((hybrid_candidatey, trainy), axis=0)
                        else:
                            selected_candidateX, selected_candidatey = targeted_model.selection(
                                budget=budget,
                                # trainX=trainX,
                                # trainy=trainy,
                                candidateX=hybrid_candidateX,
                                candidateX_id=id_feat_can,
                                candidatey=hybrid_candidatey,
                                candidatey_id=id_y_can,
                                hybrid_test=hybrid_testX,
                                hybrid_testy=hybrid_testy,
                                metric=metric,
                                id_ratio=id_ratio
                            )

                            if retrain_type == TYPE1:
                                retrainX, retrainy = selected_candidateX, selected_candidatey
                            else:
                                retrainX = np.concatenate((selected_candidateX, trainX), axis=0)
                                retrainy = np.concatenate((selected_candidatey, trainy), axis=0)

                        retrain_acc = targeted_model.retrain(candidateX=retrainX, candidatey=retrainy, testX=_testX, testy=_testy, epochs=epochs)
                        accuracies.append(retrain_acc*100)
                        ori_accs.append(ori_acc*100)
                    
                    for j in range(len(id_dist)):
                        write_to_csv(log_path, {
                            'selection_metric': metric,
                            'ood': ood,
                            'epochs': epochs,
                            'id_ratio': id_dist[j],
                            'budget': budget,
                            'original_acc': ori_accs[j],
                            'retrain_acc': accuracies[j],
                            'acc_improvement': accuracies[j] - ori_accs[j]
                        })

def main():
    for test in tests:
        retrain_outofsrc(test)

if __name__ == '__main__':
    main()
